---
layout: post
title: "The catch in `try/catch`"
date: 2025-02-25
categories:
---

Yesterday was the last of Farcaster competition on Cantina, others submissions were instantly live which is great because I get an instant feedback loop. I also got my guts twisted with a particular finding I'm documenting here.

Let me try to snip the relevant code from memory as an exercise:

```js
function foo(/* inputs */) public {
    try Verifier.verify(/* inputs */) returns (bool isVerified) {
        if (!isVerified) {
            revert();
        }
    } catch {
        // Empty catch block! Hmm...
    }

    // If verification succeeds, funds are sent from `address(this)` to `msg.sender`.
}
```

My thought process here was:
> Oh, an empty `catch` block... This smells like it could introduce a bug since it's not handling any unexpected errors. If I can trigger an error in `Verifier.verify()` function, The empty `catch` block will suppress the error and the logic to send funds will be executed next, sending funds to me!
>
> How to trigger the error?
>
> Maybe I can submit malformed inputs to `this.verify()` to trigger an error.

Honestly I was thinking I'm a genius at this point lol, until I noticed the blocker: The hash of inputs was checked to exist against some data structure before calling `Verifier.verify()`:

```js
function foo(/* inputs */) public {

@>  require(hashes[hash(/* inputs */)] != 0);

    try Verifier.verify(/* inputs */) returns (bool isVerified) {
        if (!isVerified) {
            revert();
        }
    } catch {}

    // If verification succeeds, funds are sent from `address(this)` to `msg.sender`.
}
```

I stopped here because I couldn't figure a way to trigger the `catch` block, but here's the "catch": Haxatron, m4rio et al. already triggered the `catch` block by using the 63/64 rule of EIP-150.

Next, I'm taking action to deepen understanding by:
1. Reading every submission of the issue.
2. Reading EIP-150.
3. Reading RareSkills article on `try/catch` blocks.
